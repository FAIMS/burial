<?xml version="1.0" ?>
<!--@POSTPROC: ./postproc.sh-->
<module suppressWarnings="true">

<User f="nodata">
  <User f="noscroll">
    <User    t="dropdown" f="user"/>
    <Log_in  t="button"/>
    <Sign_up t="button"/>
  </User>
</User>

<Control f="nodata">
  <Main>
    <Take_Feature t="button" l="Burial_Mound"/>
    <autonum/>
    <GPS_Diagnostics t="gpsdiag"/>
  </Main>
  <search>
    Records
  </search>
  <Table f="noscroll">
    <Table>
      <!--This is replaced with a table view using @POSTPROC-->
    </Table>
  </Table>
  <Map f="noscroll">
    <Map t="map"/>
    <cols>
      <Centre_Me t="button"/>
      <Create_Shape t="button" l="Shape"/>
    </cols>
  </Map>
</Control>

<Burial_Mound>
  <General>
    <Object_ID f="id notnull autonum"/>
    <Date f="readonly"/>
    <author/>
    <Type>
      <opts>
        <opt>Burial Mound</opt>
        <opt>Extinct Burial Mound</opt>
        <opt>Uncertain Feature</opt>
        <opt>Natural Feature</opt>
        <opt>Unknown</opt>
        <opt>Other</opt>
      </opts>
    </Type>
    <Name_or_Other_ID/>
    <Source>
      <opts>
        <opt>Survey</opt>
        <opt>Remote sensing</opt>
        <opt>Informant</opt>
        <opt>Legacy verification</opt>
        <opt>Bibliography</opt>
        <opt>Other</opt>
      </opts>
    </Source>
    <Description/>
    <Surrounding_Landuse>
      <opts>
        <opt>Annual agriculture
          <opt>Ploughed</opt>
          <opt>Harrowed</opt>
          <opt>Seedlings</opt>
          <opt>Mature crop</opt>
          <opt>Harvested</opt>
        </opt>
        <opt>Perennial
          <opt>Orchard</opt>
          <opt>Lavender</opt>
          <opt>Vineyard</opt>
        </opt>
        <opt>Other
          <opt>Meadow</opt>
          <opt>Beach</opt>
          <opt>Scrub</opt>
          <opt>Forest</opt>
          <opt>Other</opt>
        </opt>
      </opts>
    </Surrounding_Landuse>
    <Surface_Landuse>
      <opts>
        <opt>Annual agriculture
          <opt>Ploughed</opt>
          <opt>Harrowed</opt>
          <opt>Seedlings</opt>
          <opt>Mature crop</opt>
          <opt>Harvested</opt>
        </opt>
        <opt>Perennial
          <opt>Orchard</opt>
          <opt>Lavender</opt>
          <opt>Vineyard</opt>
        </opt>
        <opt>Other
          <opt>Meadow</opt>
          <opt>Beach</opt>
          <opt>Scrub</opt>
          <opt>Forest</opt>
          <opt>Other</opt>
        </opt>
      </opts>
    </Surface_Landuse>
    <Prominence>
      <opts>
        <opt>Valley Bottom or Plain</opt>
        <opt>Foothill</opt>
        <opt>Hilltop</opt>
        <opt>Ridge</opt>
        <opt>Other</opt>
      </opts>
    </Prominence>
    <gps/>
    <Elevation b="decimal">
      Elevation (MASL)
    </Elevation>
    <General_Notes/>
    <Go_to_Map t="button" l="Control/Map"/>
    <Facing_Direction>
      <opts>
        <opt>No Observation</opt>
        <opt>North</opt>
        <opt>Northeast</opt>
        <opt>East</opt>
        <opt>Southeast</opt>
        <opt>South</opt>
        <opt>Southwest</opt>
        <opt>West</opt>
        <opt>Northwest</opt>
        <opt>Other</opt>
      </opts>
    </Facing_Direction>
    <Mound_Overview_Photo t="camera">
      <desc>Take 1 general overview shot that includes the complete feature profile, and a scale. Include direction in the Annotation (from which direction was the image taken)</desc>
    </Mound_Overview_Photo>
  </General>
  <Dimensions>
    <cols>
      <col>
        <Length_Max b="decimal"/>
        <Width_Max  b="decimal"/>
        <Height_Max b="decimal"/>
        <Area_Max   b="decimal"/>
      </col>
      <col>
        <Length_Min b="decimal"/>
        <Width_Min  b="decimal"/>
        <Height_Min b="decimal"/>
        <Area_Min   b="decimal"/>
      </col>
    </cols>
    <Other_Dimension/>
    <Shape_Notes/>
    <Attach_a_Sketch t="file"/>
    <Sketch_Photo t="camera"/>
  </Dimensions>
  <Material>
    <Surface_Material_Description/>
    <Surface_Material_Density>
      <opts>
        <opt>zero</opt>
        <opt>scarce</opt>
        <opt>medium</opt>
        <opt>high</opt>
      </opts>
    </Surface_Material_Density>
    <Sample_Collected t="radio">
      Sample Collected?
      <opts>
        <opt>Yes</opt>
        <opt>No</opt>
      </opts>
    </Sample_Collected>
    <Stone_Feature_Present_And_Visible t="radio">
      Stone Feature Present And Visible?
      <opts>
        <opt>Yes</opt>
        <opt>No</opt>
      </opts>
    </Stone_Feature_Present_And_Visible>
    <Stone_Feature_Description/>
    <Material_Photo t="camera"/>
  </Material>
  <CRM>
    <Condition>
      <opts>
        <opt>No Observation</opt>
        <opt>Undisturbed</opt>
        <opt>Surface Sediment Disturbed</opt>
        <opt>Subsurface Disturbed</opt>
        <opt>Totally Disturbed</opt>
        <opt>Unknown</opt>
      </opts>
    </Condition>
    <Disturbance_Description/>
    <Principal_Factors>
      <desc>Select one factor that contributes to most visible damage</desc>
      <opts>
        <opt>No Observation</opt>
        <opt>Anthropic
          <opt>Agricultural</opt>
          <opt>Looting</opt>
          <opt>Development</opt>
          <opt>Other</opt>
        </opt>
        <opt>Post-depositional
          <opt>Mound geomorphology</opt>
          <opt>Erosion</opt>
          <opt>Wind damage</opt>
          <opt>Water damage</opt>
          <opt>Age</opt>
          <opt>Other</opt>
        </opt>
        <opt>Topographic
          <opt>Aspect</opt>
          <opt>Slope</opt>
          <opt>Exposure</opt>
          <opt>Hydrology</opt>
          <opt>Other</opt>
        </opt>
        <opt>Other</opt>
      </opts>
    </Principal_Factors>
    <Other_Sources_of_Impact t="checkbox">
      <opts>
        <opt>anthropic</opt>
        <opt>animal activity</opt>
        <opt>post depositional</opt>
        <opt>topographic</opt>
      </opts>
    </Other_Sources_of_Impact>
    <Age_of_Damage t="checkbox">
      <opts>
        <opt>Remote</opt>
        <opt>Recent</opt>
        <opt>Fresh</opt>
      </opts>
    </Age_of_Damage>
    <RT_Number b="decimal"/>
    <RT_Kind t="checkbox">
      <opts>
        <opt>Basic pit</opt>
        <opt>Trench</opt>
        <opt>Tunnel</opt>
      </opts>
    </RT_Kind>
    <RT_Method t="checkbox">
      <opts>
        <opt>Manual</opt>
        <opt>Mechanized</opt>
      </opts>
    </RT_Method>
    <RT_Description/>
    <Volume_of_Soil_Removed_via_RT>
      <opts>
        <opt>&lt;10%</opt>
        <opt>10-20%</opt>
        <opt>20-30%</opt>
        <opt>30-40%</opt>
        <opt>40-40%</opt>
        <opt>50-40%</opt>
        <opt>60-40%</opt>
        <opt>70-40%</opt>
        <opt>80-40%</opt>
        <opt>90-100%</opt>
      </opts>
    </Volume_of_Soil_Removed_via_RT>
    <Affect f="notnull">
      <desc>1=0-20% of the entire feature is missing or disrupted, 5= 80-100% of the feature's surface is missing or disrupted</desc>
      <opts>
        <opt>1</opt>
        <opt>2</opt>
        <opt>3</opt>
        <opt>4</opt>
        <opt>5</opt>
      </opts>
    </Affect>
    <Impact f="notnull">
      <desc>1 = context is nearly intact; 5 = original context of the feature is nearly all destroyed</desc>
      <opts>
        <opt>1</opt>
        <opt>2</opt>
        <opt>3</opt>
        <opt>4</opt>
        <opt>5</opt>
      </opts>
    </Impact>
    <Comments_and_Recommendations/>
    <CRM_Photo t="camera"/>
  </CRM>
</Burial_Mound>

<Shape>
  <Shape_Note>
    <Label f="id"/>
    <Note/>
  </Shape_Note>
</Shape>

<logic><![CDATA[
/************************************ MAP *************************************/
DATA_ENTRY_LAYER    = "Data Entry Layer";
DATA_ENTRY_LAYER_ID = 0;

void initMap() {
  String refMap = "Control/Map/Map";

  setMapZoom(refMap, 15.0f);

  // Shape
  isEntity = true;
  queryName = "Shape";
  querySQL = "SELECT uuid, aenttimestamp FROM latestNonDeletedArchEnt join aenttype using (aenttypeid) where aenttypename = 'Shape'";
  ps = createPointStyle(10, Color.YELLOW, 0.2f, 0.5f);
  ls = createLineStyle(10, Color.YELLOW, 0.05f, 0.3f, null);
  pos = createPolygonStyle(10, Color.parseColor("#440000FF"), createLineStyle(10, Color.parseColor("#AA000000"), 0.01f, 0.3f, null));
  ts = createTextStyle(10, Color.YELLOW, 30, Typeface.SANS_SERIF);
  showDatabaseLayer(refMap, "Shape Layer", isEntity, queryName, querySQL, ps, ls, pos, ts);

  // Data entry layer
  DATA_ENTRY_LAYER_ID = createCanvasLayer(refMap, DATA_ENTRY_LAYER);
  setSelectedLayer(refMap, DATA_ENTRY_LAYER);
}

// Copy/pasted from autogenerator's definition of saveTabGroup
void saveShape() {
  String  tabgroup            = "Shape";
  Boolean enableAutosave      = true;
  String  id                  = getUuid(tabgroup);
  String  mapRef              = "Control/Map/Map";
  List    geometry            = getGeometryList(mapRef, DATA_ENTRY_LAYER_ID);
  List    attributes          = null;
  String  parentTabgroup_     = parentTabgroup;
  String  parentTabgroupUuid_ = getUuid(parentTabgroup_);
  Boolean userWasSet          = !username.equals("");

  String callback = "";
  callback += "; clearGeometry()";
  callback += "; onSave" + getArchEntTypePascalCased(tabgroup) + "__()";

  parentTabgroup = null;

  SaveCallback saveCallback  = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabgroup, uuid);
      // Make a child-parent relationship if need be.
      if (
          newRecord &&
          !isNull(parentTabgroup_) &&
          !isNull(parentTabgroupUuid_)
      ) {
        String rel = "";
        rel += parentTabgroup_.replaceAll("_", " ");
        rel += " - ";
        rel += tabgroup.replaceAll("_", " ");
        saveEntitiesToHierRel(
          rel,
          parentTabgroupUuid_,
          uuid,
          "Parent Of",
          "Child Of",
          callback
        );
      } else {
        execute(callback);
      }

      // This fixes an interesting bug. Without this, if a user was not set
      // (by calling `setUser`) at the time `saveShape` was first called, but
      // set by the time `onSave` was called, the tab group is saved correctly
      // the first time only.
      //
      // Adding this allows subsequent saves to succeed. Presumably it plays
      // some role in helping FAIMS associate the correct user with a record.
      if (!userWasSet) {
        saveShape();
      }

    }
    onError(message) {
      showToast(message);
    }
  };

  saveTabGroup(tabgroup, id, geometry, attributes, saveCallback, enableAutosave);
}

void clearGeometry() {
  String  mapRef   = "Control/Map/Map";
  List    geometry = getGeometryList(mapRef, DATA_ENTRY_LAYER_ID);

  if (geometry == null)     return;
  if (geometry.size() == 0) return;

  for (geom : geometry) {
    print("Geometry cleared:" + geom.userData.geomId);
    clearGeometry(mapRef, geom.userData.geomId);
  }
}

boolean checkForGeometry() {
  String mapRef = "Control/Map/Map";

  List geometry = getGeometryList(mapRef, DATA_ENTRY_LAYER_ID);
  if (geometry == null || geometry.size() == 0) {
    String head = "Cannot Create Shape";
    String body = "At least one shape must be present on the data entry layer.";
    showWarning(head, body);

    return false;
  } else {
    return true;
  }
}

void centreMe() {
  String mapRef = "Control/Map/Map";

  if(!isExternalGPSOn() && !isInternalGPSOn()) {
    showToast("{GPS_Not_Initialised}");
  } else {
    centerOnCurrentPosition(mapRef);
  }
}

void refreshMap() {
  String mapRef = "Control/Map/Map";
  refreshMap(mapRef);
}

// Overrides autogenerated definition
void onClickControlMapCreateShape () {
  if (checkForGeometry()) {
    parentTabgroup__ = "Control";
    newShape();
  }
}

// Overrides autogenerated definition
void onShowShape () {
  saveShape();
}

initMap();
addOnEvent("Control/Map/Centre_Me", "click", "centreMe()");
addOnEvent("Control/Map",           "show",  "refreshMap()");

/****************************** DATE POPULATION *******************************/
  void setDayMonth() {
    ref     = "Burial_Mound/General/Date";

    fmt     = "dd MMM";
    date    = new Date();
    dateFmt = new java.text.SimpleDateFormat(fmt);
    dateStr = dateFmt.format(date);

    setFieldValue(ref, dateStr);
  }

  addOnEvent("Burial_Mound", "create", "setDayMonth()");

/********************************* TABLE VIEW *********************************/
  query  = "select uuid, 'identifier' as attributename, response, -1 as aentcountorder ";
  query += " from latestNonDeletedArchEntFormattedIdentifiers ";
  query += "where aenttypename='Burial Mound'";
  query += " union ";
  query += "select uuid, attributename, group_concat(format(formatstring, vocabname, measure, freetext, certainty), appendcharacterstring) as response, aentcountorder ";
  query += "  from ( ";
  query += "    select uuid, attributename, aenttypename, formatstring, vocabname, measure, freetext, certainty, appendcharacterstring, aentcountorder, vocabcountorder, attributeid ";
  query += "    from latestNonDeletedArchent ";
  query += "      JOIN aenttype using (aenttypeid) ";
  query += "      join idealaent using (aenttypeid) ";
  query += "      join attributekey using (attributeid) ";
  query += "      join latestNonDeletedAentValue using (uuid, attributeid) ";
  query += "      left outer join vocabulary using (attributeid, vocabid) ";
  query += "    order by uuid, aentcountorder, vocabcountorder ";
  query += "  ) ";
  query += "  where aenttypename='Burial Mound' ";
  query += "  and attributename in ('Object ID', 'Type', 'Date', 'Surrounding Landuse', 'Surface Landuse', 'Height Max', 'Length Max') ";
  query += "  group by uuid, attributeid ";
  query += "  having response is not null ";
  query += "  order by uuid, aentcountorder; ";

  tableRef       = "Control/Table/Table";
  headers        = new ArrayList();
  actionName     = "Load";
  actionIdx      = 0;
  actionCallback = "loadEntityFromTable()";

  headers.add("");
  headers.add("Object ID");
  headers.add("Type");
  headers.add("Date");
  headers.add("Surrounding Landuse");
  headers.add("Surface Landuse");
  headers.add("Height Max");
  headers.add("Length Max");

  populateTable() {
    populateTablePivot(tableRef, query, headers, actionName, actionIdx, actionCallback);
  }

  loadEntityFromTable() {
    uuid = getTableValue();
    loadEntityFrom(uuid); // Auto-gen'd function
  }

  addOnEvent(tableRef, "show", "populateTable()");

/*********************************** LOGIN ************************************/
  // Overrides autogenerated definition
  selectUser () {
    String userVocabId  = getFieldValue(userMenuPath);
    if (isNull(userVocabId))
      return;

    String userQ = "SELECT userid,fname,lname,email,password FROM user " +
                   "WHERE  userid='" + userVocabId + "';";
    FetchCallback callback = new FetchCallback() {
      onFetch(result) {
        user = new User(
              result.get(0),
              result.get(1),
              result.get(2),
              result.get(3),
              result.get(4)
        );
        setUser(user);
        username = result.get(1) + " " + result.get(2);
      }
    };

    fetchOne(userQ, callback);
  }

  onClickLogin () {
    showVerifyUserDialog("doUserLogin()");
  }

  onClickSignup () {
    setSyncEnabled(true);
    showCreateUserDialog("signupSuccessful()");
  }

  signupSuccessful() {
    String head  = "Signup Successful";
    String body  = "You have successfuly signed up. You may now log in as the ";
           body += "newly created user.";

    showWarning(head, body);
    populateListForUsers();
  }

  doUserLogin () {
    newTab("Control", true);
  }

  addOnEvent("User/User/Log_in",  "click", "onClickLogin()");
  addOnEvent("User/User/Sign_up", "click", "onClickSignup()");

]]></logic>

</module>
